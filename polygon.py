# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'page_main.ui'
#
# Created by: PyQt5 UI code generator 5.15.1
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

import sys

from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPen, QBrush
from PyQt5.QtWidgets import QGraphicsScene, QMessageBox

class Point():
    def __init__(self, x, y, t=0, dis=0):
        self.x = x
        self.y = y
        self.dis = dis
        self.type = t # 0: ori, 1: intersection

    def __gt__(self, other):
        return self.x > other.x

    def __lt__(self, other):
        return self.x < other.x

class Ui_pageMain(object):
    def setupUi(self, pageMain):
        self.count_left = 0
        self.count_right = 0
        self.left = []
        self.right = []
        self.left_flag = False
        self.right_flag = False
        self.begin = -1
        self.begin_right = -1

        pageMain.setObjectName("pageMain")
        pageMain.resize(960, 720)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(pageMain.sizePolicy().hasHeightForWidth())
        pageMain.setSizePolicy(sizePolicy)
        pageMain.setMinimumSize(QtCore.QSize(960, 720))
        pageMain.setMaximumSize(QtCore.QSize(960, 720))
        self.centralwidget = QtWidgets.QWidget(pageMain)
        self.centralwidget.setObjectName("centralwidget")
        self.layoutWidget = QtWidgets.QWidget(self.centralwidget)
        self.layoutWidget.setGeometry(QtCore.QRect(15, 10, 931, 661))
        self.layoutWidget.setObjectName("layoutWidget")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.layoutWidget)
        self.verticalLayout.setContentsMargins(0, 0, 0, 0)
        self.verticalLayout.setObjectName("verticalLayout")
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.graphicsView = QtWidgets.QGraphicsView(self.layoutWidget)
        self.graphicsView.setObjectName("graphicsView")
        self.horizontalLayout_2.addWidget(self.graphicsView)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout = QtWidgets.QHBoxLayout()
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.radio_left = QtWidgets.QRadioButton(self.layoutWidget)
        self.radio_left.setObjectName("radio_left")
        self.horizontalLayout.addWidget(self.radio_left)
        self.radio_right = QtWidgets.QRadioButton(self.layoutWidget)
        self.radio_right.setObjectName("radio_right")
        self.horizontalLayout.addWidget(self.radio_right)
        spacerItem = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem)
        self.label_note = QtWidgets.QLabel(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("Consolas")
        self.label_note.setFont(font)
        self.label_note.setText("")
        self.label_note.setObjectName("label_note")
        self.horizontalLayout.addWidget(self.label_note)
        spacerItem1 = QtWidgets.QSpacerItem(40, 20, QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Minimum)
        self.horizontalLayout.addItem(spacerItem1)
        self.btn_clip = QtWidgets.QPushButton(self.layoutWidget)
        self.btn_clear = QtWidgets.QPushButton(self.layoutWidget)
        font = QtGui.QFont()
        font.setFamily("Consolas")
        self.btn_clip.setFont(font)
        self.btn_clip.setObjectName("btn_clip")
        self.horizontalLayout.addWidget(self.btn_clip)
        self.btn_clear.setFont(font)
        self.btn_clear.setObjectName("btn_clear")
        self.horizontalLayout.addWidget(self.btn_clear)
        self.verticalLayout.addLayout(self.horizontalLayout)
        pageMain.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(pageMain)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 960, 22))
        self.menubar.setObjectName("menubar")
        pageMain.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(pageMain)
        self.statusbar.setObjectName("statusbar")
        pageMain.setStatusBar(self.statusbar)

        self.retranslateUi(pageMain)
        QtCore.QMetaObject.connectSlotsByName(pageMain)

        self.radio_left.setChecked(True)
        self.graphicsView.scene = QGraphicsScene(self.graphicsView)
        self.graphicsView.setScene(self.graphicsView.scene)
        self.graphicsView.setAlignment(QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
        self.graphicsView.mousePressEvent = self.pixelSelect

        self.btn_clip.clicked.connect(self.clip)
        self.btn_clear.clicked.connect(self.clear)

    def retranslateUi(self, pageMain):
        _translate = QtCore.QCoreApplication.translate
        pageMain.setWindowTitle(_translate("pageMain", "MainWindow"))
        self.radio_left.setText(_translate("pageMain", "主多边形"))
        self.radio_right.setText(_translate("pageMain", "裁剪多边形"))
        self.btn_clip.setText(_translate("pageMain", "   裁剪   "))
        self.btn_clear.setText(_translate("pageMain", "   清空   "))

    def clear(self):
        self.count_left = 0
        self.count_right = 0
        self.left = []
        self.right = []
        self.left_flag = False
        self.right_flag = False
        self.begin = -1
        self.begin_right = -1
        self.graphicsView.scene.clear()

    def getCross(self, start1, end1, start2, end2):
        x1, y1, x2, y2, x3, y3, x4, y4 = start1.x, start1.y, end1.x, end1.y, start2.x, start2.y, end2.x, end2.y
        det = lambda a, b, c, d: a * d - b * c
        d = det(x1 - x2, x4 - x3, y1 - y2, y4 - y3)
        p = det(x4 - x2, x4 - x3, y4 - y2, y4 - y3)
        q = det(x1 - x2, x4 - x2, y1 - y2, y4 - y2)
        if d != 0:
            lam, eta = p / d, q / d
            if not (0 <= lam <= 1 and 0 <= eta <= 1): return []
            return [lam * x1 + (1 - lam) * x2, lam * y1 + (1 - lam) * y2]
        if p != 0 or q != 0: return []
        t1, t2 = sorted([start1, end1]), sorted([start2, end2])
        if t1[1] < t2[0] or t2[1] < t1[0]: return []
        return max(t1[0], t2[0])

    def clip(self):
        if self.left == [] or self.right == []:
            return
        tmp_left = []
        tmp_right = []

        # 裁剪多边形序列
        for i in range(0, len(self.left)):
            inter_list = []
            for j in range(0, len(self.right)):
                if i < len(self.left) - 1 and j < len(self.right) - 1:
                    tmp = self.getCross(self.left[i], self.left[i + 1], self.right[j], self.right[j + 1])
                if i < len(self.left) - 1 and j == len(self.right) - 1:
                    tmp = self.getCross(self.left[i], self.left[i + 1], self.right[j], self.right[0])
                if i == len(self.left) - 1 and j < len(self.right) - 1:
                    tmp = self.getCross(self.left[i], self.left[0], self.right[j], self.right[j + 1])
                if i == len(self.left) - 1 and j == len(self.right) - 1:
                    tmp = self.getCross(self.left[i], self.left[0], self.right[j], self.right[0])

                if len(tmp) != 0:
                    intersection =  Point(int(tmp[0]), int(tmp[1]), 1, abs(self.left[i].x - tmp[0]+ self.left[i].y - tmp[1]))
                    inter_list.append(intersection)

                    pen = QPen(QtCore.Qt.blue)
                    brush = QBrush(QtCore.Qt.blue)
                    self.graphicsView.scene.addEllipse(intersection.x, intersection.y, 4, 4, pen, brush)

            inter_list = sorted(inter_list, key=lambda point: point.dis)

            if i == 0:
                tmp_left.append([self.left[i].x, self.left[i].y, self.left[i].type])

            if len(inter_list) != 0 and self.begin == -1:
                self.begin = len(tmp_left)

            for k in range(0, len(inter_list)):
                tmp_left.append([inter_list[k].x, inter_list[k].y, inter_list[k].type])
            if i < len(self.left) - 1:
                tmp_left.append([self.left[i + 1].x, self.left[i + 1].y, self.left[i + 1].type])
            if i == len(self.left) - 1:
                pass

            # if self.begin != -1:
            #     pen = QPen(QtCore.Qt.green)
            #     brush = QBrush(QtCore.Qt.green)
            #     self.graphicsView.scene.addEllipse(tmp_left[self.begin].x, tmp_left[self.begin].y, 4, 4, pen, brush)

        # 主多边形序列
        for i in range(0, len(self.right)):
            inter_list = []
            for j in range(0, len(self.left)):
                if i < len(self.right) - 1 and j < len(self.left) - 1:
                    tmp = self.getCross(self.right[i], self.right[i + 1], self.left[j], self.left[j + 1])
                if i < len(self.right) - 1 and j == len(self.left) - 1:
                    tmp = self.getCross(self.right[i], self.right[i + 1], self.left[j], self.left[0])
                if i == len(self.right) - 1 and j < len(self.left) - 1:
                    tmp = self.getCross(self.right[i], self.right[0], self.left[j], self.left[j + 1])
                if i == len(self.right) - 1 and j == len(self.left) - 1:
                    tmp = self.getCross(self.right[i], self.right[0], self.left[j], self.left[0])

                if len(tmp) != 0:
                    intersection =  Point(int(tmp[0]), int(tmp[1]), 1, abs(self.right[i].x - tmp[0]+ self.right[i].y - tmp[1]))
                    inter_list.append(intersection)

                    pen = QPen(QtCore.Qt.blue)
                    brush = QBrush(QtCore.Qt.blue)
                    self.graphicsView.scene.addEllipse(intersection.x, intersection.y, 4, 4, pen, brush)

            inter_list = sorted(inter_list, key=lambda point: point.dis)

            if i == 0:
                tmp_right.append([self.right[i].x, self.right[i].y, self.right[i].type])

            if len(inter_list) != 0 and self.begin_right == -1:
                self.begin_right = len(tmp_right)

            for k in range(0, len(inter_list)):
                tmp_right.append([inter_list[k].x, inter_list[k].y, inter_list[k].type])
            if i < len(self.right) - 1:
                tmp_right.append([self.right[i + 1].x, self.right[i + 1].y, self.right[i + 1].type])
            if i == len(self.right) - 1:
                pass

            # if self.begin_right != -1:
            #     pen = QPen(QtCore.Qt.yellow)
            #     brush = QBrush(QtCore.Qt.yellow)
            #     self.graphicsView.scene.addEllipse(tmp_right[self.begin_right].x, tmp_right[self.begin_right].y, 4, 4, pen, brush)

        # if (not self.reorderClockwise(tmp_right) and self.reorderClockwise(tmp_left)) or (self.reorderClockwise(tmp_right) and not self.reorderClockwise(tmp_left)):
        #     tmp_right.reverse()
        #     print('reverse')
        
        # if self.reorderClockwise(tmp_right):
        #     tmp_point = tmp_right[0]
        #     tmp_right.reverse()
        #     tmp_right.pop()
        #     tmp_right.insert(0, tmp_point)
        #     self.begin_right = len(tmp_right) - self.begin_right

        # if self.reorderClockwise(tmp_left):
        #     tmp_point = tmp_left[0]
        #     tmp_left.reverse()
        #     tmp_left.pop()
        #     tmp_left.insert(0, tmp_point)
        #     self.begin = len(tmp_left) - self.begin

        if (self.reorderClockwise(tmp_left) and not self.reorderClockwise(tmp_right)) or (not self.reorderClockwise(tmp_left) and self.reorderClockwise(tmp_right)):
            print('reverse list')
            tmp_point = tmp_right[0]
            tmp_right.reverse()
            tmp_right.pop()
            tmp_right.insert(0, tmp_point)
            self.begin_right = len(tmp_right) - self.begin_right

        # 绘制
        # for i in tmp_left:
        #     print(i[0], i[1])

        # print('')
        # for i in tmp_right:
        #     print(i[0], i[1])
        # for i in range(0, len(tmp_left)):
        #     tmp_text = self.graphicsView.scene.addText(str(i))
        #     tmp_text.setPos(tmp_left[i][0], tmp_left[i][1])
        #     tmp_text.setDefaultTextColor(QtCore.Qt.red)

        # for i in range(0, len(tmp_right)):
        #     tmp_text = self.graphicsView.scene.addText(str(i))
        #     tmp_text.setPos(tmp_right[i][0], tmp_right[i][1])
        #     tmp_text.setDefaultTextColor(QtCore.Qt.blue)
        
        tmp_right_tmp = [[]]
        for i in self.right:
            tmp_right_tmp[0].append([i.x, i.y])

        tmp_left_tmp = [[]]
        for i in self.left:
            tmp_left_tmp[0].append([i.x, i.y])
        
        if self.begin == -1:
            if self.isPoiWithinPoly([tmp_left[0][0], tmp_left[0][1]], tmp_right_tmp):
                print('in')
                for i in range(0, len(tmp_left)):
                    pen = QPen(QtCore.Qt.blue)
                    if i == len(tmp_left) - 1:
                        self.graphicsView.scene.addLine(tmp_left[i].x, tmp_left[i].y, tmp_left[0][0], tmp_left[0][1], pen)
                    else:
                        self.graphicsView.scene.addLine(tmp_left[i].x, tmp_left[i].y, tmp_left[i + 1][0], tmp_left[i + 1][1], pen)
            else:
                if self.isPoiWithinPoly([self.right[0].x, self.right[0].y], tmp_left_tmp):
                    print('reverse in')
                    for i in range(0, len(tmp_left)):
                        pen = QPen(QtCore.Qt.blue)
                        if i == len(tmp_left) - 1:
                            self.graphicsView.scene.addLine(self.right[i].x, self.right[i].y, self.right[0].x, self.right[0].y, pen)
                        else:
                            self.graphicsView.scene.addLine(self.right[i].x, self.right[i].y, self.right[i + 1].x, self.right[i + 1].y, pen)
                else:
                    print('out')
        else:
            print('clip', self.begin, [tmp_left[self.begin - 1][0], tmp_left[self.begin - 1][1]], tmp_right_tmp)
            out_list = []
            if self.isPoiWithinPoly([tmp_left[self.begin - 1][0], tmp_left[self.begin - 1][1]], tmp_right_tmp): # 起始为出点
                print('clip out')
                count = 0
                count = self.begin_right
                flag = False
                close = True
                for i in range(0, self.begin):
                    out_list.append(tmp_left[i])
                out_list.append(tmp_right[count])
                while close:
                    if flag: # 入点，left
                        i = count + 1
                        print(i)
                        if i == len(tmp_left):
                            out_list.append(tmp_left[0])
                            close = False
                            break
                        
                        while i < len(tmp_left):
                            if out_list.count(tmp_left[i]) > 0:
                                out_list.append(tmp_left[i])
                                print('leftb', i, tmp_left[i][0],tmp_left[i][1])
                                close = False
                                break

                            out_list.append(tmp_left[i])
                            print('left', i, tmp_left[i][0],tmp_left[i][1])
                            if tmp_left[i][2] == 1: 
                                print('l2r')
                                flag = False
                                count = tmp_right.index(tmp_left[i])
                                break

                            i += 1
                    else:
                        i = 1
                        while i < len(tmp_right) + 1:
                            if out_list.count(tmp_right[(count + i) % len(tmp_right)]) > 0:
                                out_list.append(tmp_right[(count + i) % len(tmp_right)])
                                print('rightb', (count + i) % len(tmp_right))
                                close = False
                                break

                            out_list.append(tmp_right[(count + i) % len(tmp_right)])
                            print('right', (count + i) % len(tmp_right))
                            if tmp_right[(count + i) % len(tmp_right)][2] == 1: 
                                print('r2l')
                                flag = True
                                count = tmp_left.index(tmp_right[(count + i) % len(tmp_right)])
                                break
                            i += 1

                for i in range(0, len(out_list)):
                    pen = QPen(QtCore.Qt.blue)
                    if i == len(out_list) - 1:
                        self.graphicsView.scene.addLine(out_list[i][0], out_list[i][1], out_list[0][0], out_list[0][1], pen)
                    else:
                        self.graphicsView.scene.addLine(out_list[i][0], out_list[i][1], out_list[i + 1][0], out_list[i + 1][1], pen)

            else: # 起始为入点
                print('clip in')
                # out_list.append(tmp_left[self.begin])
                count = 0
                count = self.begin
                flag = True
                close = True
                out_list.append(tmp_left[count])
                while close:
                    if flag: # 入点，left
                        i = count + 1
                        while i < len(tmp_left):
                            if out_list.count(tmp_left[i]) > 0:
                                out_list.append(tmp_left[i])
                                print('leftb', i, tmp_left[i][0],tmp_left[i][1])
                                close = False
                                break

                            out_list.append(tmp_left[i])
                            print('left', i, tmp_left[i][0],tmp_left[i][1])
                            if tmp_left[i][2] == 1: 
                                print('l2r')
                                flag = False
                                count = tmp_right.index(tmp_left[i])
                                break
                            if i == len(tmp_left) - 1:
                                out_list.append(tmp_left[0])
                                close = False
                                break

                            i += 1
                    else:
                        i = 1
                        while i < len(tmp_right) + 1:
                            if out_list.count(tmp_right[(count + i) % len(tmp_right)]) > 0:
                                out_list.append(tmp_right[(count + i) % len(tmp_right)])
                                print('rightb', (count + i) % len(tmp_right))
                                close = False
                                break

                            out_list.append(tmp_right[(count + i) % len(tmp_right)])
                            print('right', (count + i) % len(tmp_right))
                            if tmp_right[(count + i) % len(tmp_right)][2] == 1: 
                                print('r2l')
                                flag = True
                                count = tmp_left.index(tmp_right[(count + i) % len(tmp_right)])
                                break
                            i += 1

                for i in range(0, len(out_list)):
                    pen = QPen(QtCore.Qt.blue)
                    if i == len(out_list) - 1:
                        self.graphicsView.scene.addLine(out_list[i][0], out_list[i][1], out_list[0][0], out_list[0][1], pen)
                    else:
                        self.graphicsView.scene.addLine(out_list[i][0], out_list[i][1], out_list[i + 1][0], out_list[i + 1][1], pen)

    # def reorderClockwise(self, check_list):
    #     polygon_point = []
    #     for i in check_list:
    #         polygon_point.append([i[0], i[1]])

    #     pp = np.array(polygon_point)  
        
    #     if (pp[0] == pp[-1]).all():
    #         pp = np.delete(pp, -1, axis=0)
    #     x = pp[:, 0]
    #     y = pp[:, 1]
        
    #     max_y_index = np.argmax(y)    
        
    #     pre_index = max_y_index -1
    #     next_index = 0 if max_y_index == len(pp) - 1 else max_y_index + 1

    #     if x[pre_index] < x[next_index]:
    #         return False # 顺时针
    #     else:
    #         return True # 逆时针
    def reorderClockwise(self, check_list):
        polygon = []
        for i in check_list:
            polygon.append([i[0], i[1]])

        sz = len(polygon)
        greaterC = 0
        lessC = 0
        for i in range(0, len(polygon)):
            a = polygon[i]
            b = polygon[(i + 1) % sz]
            c = polygon[(i + 2) % sz]
            if (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0]) > 0:
                greaterC += 1;
            else:
                lessC += 1;
        if greaterC > lessC:
            return True
        else:
            return False

    def isRayIntersectsSegment(self, poi, s_poi, e_poi): 
        if s_poi[1] == e_poi[1]: 
            return False
        if s_poi[1] > poi[1] and e_poi[1] > poi[1]: 
            return False
        if s_poi[1] < poi[1] and e_poi[1] < poi[1]: 
            return False
        if s_poi[1] == poi[1] and e_poi[1] > poi[1]: 
            return False
        if e_poi[1] == poi[1] and s_poi[1] > poi[1]: 
            return False
        if s_poi[0] < poi[0] and e_poi[1] < poi[1]: 
            return False

        xseg = e_poi[0] - (e_poi[0] - s_poi[0]) * (e_poi[1] - poi[1]) / (e_poi[1] - s_poi[1]) 

        if xseg < poi[0]: 
            return False
        return True 

    # def isPoiWithinPoly(self, poi, poly):
    #     sinsc = 0 
    #     for epoly in poly:
    #         for i in range(len(epoly) - 1): 
    #             s_poi = epoly[i]
    #             e_poi = epoly[i + 1]
    #             if self.isRayIntersectsSegment(poi, s_poi, e_poi):
    #                 sinsc += 1 

    #     return True if sinsc % 2 == 1 else  False

    def isPoiWithinPoly(self, poi, poly):
        # 0 表示在多边形外 1表示在多边形内 -1表示在多边形上
        poly = poly[0]
        count = 0;
        for i in range(0, len(poly)):
            p1 = poly[i]
            p2 = []
            if i == len(poly) - 1:
                p2 = poly[0]
            else:
                p2 = poly[i + 1]
            if (poi[1] >= p1[1] and poi[1] <= p2[1]) or (poi[1] >= p2[1] and poi[1] <= p1[1]): 
                t = (poi[1] - p1[1]) / (p2[1] - p1[1]);
                xt = p1[0] + t * (p2[0] - p1[0]);
                if poi[0] == xt:
                    # return -1
                    print('point on')
                    return True
                if poi[0] < xt: 
                    count += 1
        if count % 2:
            # return 1
            print('point in')
            return True
        else:
            # return 0
            print('point out')
            return False

    def crossTest(self, p1, p2, p3):
        x1 = p2.x - p1.x
        y1 = p2.y - p1.y
        x2 = p3.x - p1.x
        y2 = p3.y - p1.y
        return x1 * y2 - x2 * y1 

    def isCross(self, p1, p2, p3, p4):
        if(max(p1.x, p2.x) > min(p3.x, p4.x)    
        and max(p3.x, p4.x) > min(p1.x, p2.x)   
        and max(p1.y, p2.y) > min(p3.y, p4.y)   
        and max(p3.y, p4.y) > min(p1.y, p2.y)): 

            if (self.crossTest(p1, p2, p3) * self.crossTest(p1, p2, p4) < 0 and self.crossTest(p3, p4, p1) * self.crossTest(p3, p4, p2) < 0):
                ret = True
            else:
                ret = False
        else:
            ret = False
        return ret

    def pixelSelect(self, event):
        self.graphicsView.scene.addText('').setPos(0, 0)

        x = event.x()
        y = event.y()
        point = Point(x, y)

        if event.buttons () == QtCore.Qt.LeftButton:
            if self.radio_left.isChecked():
                if self.left_flag:
                    return

                if self.count_left >= 3:
                    for i in range(0, len(self.left) - 2):
                        if self.isCross(self.left[i], self.left[i + 1], self.left[len(self.left) - 1], point): 
                            msgBox = QMessageBox()
                            msgBox.setWindowTitle(u'提示')
                            msgBox.setText(u"\n不可相交")
                            msgBox.show()
                            return

                pen = QPen(QtCore.Qt.black)
                brush = QBrush(QtCore.Qt.black)

                self.count_left = self.count_left + 1

                self.graphicsView.scene.addEllipse(x, y, 4, 4, pen, brush)

                # tmp_text = self.graphicsView.scene.addText(str(self.count_left))
                # tmp_text.setPos(x, y)
                # tmp_text.setDefaultTextColor(QtCore.Qt.black)

                if self.count_left != 1:
                    tmp = self.left[len(self.left) - 1]
                    self.graphicsView.scene.addLine(tmp.x, tmp.y, x, y, pen)

                self.left.append(point)

            if self.radio_right.isChecked():
                if self.right_flag:
                    return

                if self.count_right >= 3:
                    for i in range(0, len(self.right) - 2):
                        if self.isCross(self.right[i], self.right[i + 1], self.right[len(self.right) - 1], point): 
                            msgBox = QMessageBox()
                            msgBox.setWindowTitle(u'提示')
                            msgBox.setText(u"\n不可相交")
                            msgBox.show()
                            return

                pen = QPen(QtCore.Qt.red)
                brush = QBrush(QtCore.Qt.red)

                self.count_right = self.count_right + 1

                self.graphicsView.scene.addEllipse(x, y, 4, 4, pen, brush)

                # tmp_text = self.graphicsView.scene.addText(str(self.count_right))
                # tmp_text.setPos(x, y)
                # tmp_text.setDefaultTextColor(QtCore.Qt.red)

                if self.count_right != 1:
                    tmp = self.right[len(self.right) - 1]
                    self.graphicsView.scene.addLine(tmp.x, tmp.y, x, y, pen)

                self.right.append(point)

        if event.buttons () == QtCore.Qt.RightButton:
            if self.radio_left.isChecked():
                if self.count_left >= 3:
                    for i in range(0, len(self.left) - 2):
                        if self.isCross(self.left[i], self.left[i + 1], self.left[len(self.left) - 1], self.left[0]): 
                            msgBox = QMessageBox()
                            msgBox.setWindowTitle(u'提示')
                            msgBox.setText(u"\n不可相交")
                            msgBox.show()
                            return

                pen = QPen(QtCore.Qt.black)
                brush = QBrush(QtCore.Qt.black)

                if self.count_left >= 3:
                    begin = self.left[0]
                    end = self.left[len(self.left) - 1]
                    self.graphicsView.scene.addLine(begin.x, begin.y, end.x, end.y, pen)
                    self.left_flag = True
                else:
                    msgBox = QMessageBox()
                    msgBox.setWindowTitle(u'提示')
                    msgBox.setText(u"\n请点击至少三个点")
                    msgBox.show()

            if self.radio_right.isChecked():
                if self.count_right >= 3:
                    for i in range(0, len(self.right) - 2):
                        if self.isCross(self.right[i], self.right[i + 1], self.right[len(self.right) - 1], self.right[0]): 
                            msgBox = QMessageBox()
                            msgBox.setWindowTitle(u'提示')
                            msgBox.setText(u"\n不可相交")
                            msgBox.show()
                            return

                pen = QPen(QtCore.Qt.red)
                brush = QBrush(QtCore.Qt.red)

                if self.count_right >= 3:
                    begin = self.right[0]
                    end = self.right[len(self.right) - 1]
                    self.graphicsView.scene.addLine(begin.x, begin.y, end.x, end.y, pen)
                    self.right_flag = True
                else:
                    msgBox = QMessageBox()
                    msgBox.setWindowTitle(u'提示')
                    msgBox.setText(u"\n请点击至少三个点")
                    msgBox.show()

if __name__ == "__main__":
    app = QtWidgets.QApplication(sys.argv)
    MainWindow = QtWidgets.QMainWindow()
    ui = Ui_pageMain()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())


